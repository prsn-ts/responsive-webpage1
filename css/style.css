/* 레이아웃 */
body {background: url(../img/header_bg.jpg) repeat-x center top; }
#nav {background: #f6fdff;} /* 영역 구분을 위한 색상 지정 */
#title {background: #eaf7fd; padding: 5px 0; margin: -4px 0 0;} /* 타이틀 전체 영역 색상 지정 */
#cont_entire .container {
	border-right: 1px solid #dbdbdb;
	border-left: 1px solid #dbdbdb;
} 
/* 컨텐츠 전체 영역 레이아웃 설정(레이아웃 영역 설정시 Tip! -> 가로, 세로, 배경색을 지정하여 영역을 눈으로 확실히 확인하고 계속 진행하기) */
.cont_entire {overflow: hidden;}
.content_left {float: left; width: 250px; /*margin-top: 10px;/ height: 1000px;/ background: #ccc; -> 왼쪽, 가운데, 오른쪽 컨텐츠 영역 설정시 확인용 코드*/}
.content_center {overflow: hidden; min-height: 1300px; margin-right: 250px; border-right: 1px solid #dbdbdb; border-left: 1px solid #dbdbdb;} 
.content_right {position: absolute; top: 0; right: 0; width: 250px; /*margin-top: 10px;/ height: 1000px;/ background: #ccc;-> 왼쪽, 가운데, 오른쪽 컨텐츠 영역 설정시 확인용 코드*/}
#footer {
	border-top: 1px solid #dbdbdb; 
} /* footer 전체 영역 레이아웃 설정 */

/* 컨테이너 */
.container {position: relative; /*.content_right{position: absolute;}의 기준점이다*/ width: 1200px; margin: 0 auto; /* background: rgba(0,0,0,0.3); */}

/* 헤더 */
.header .header_menu {text-align: right;}
.header .header_menu a {color: #fff; padding: 8px 0 6px 10px; display: inline-block; 
	transition: color 0.3s ease; font-family: 'Abel', sans-serif;}
.header .header_menu a:hover {color: #ccc;}

.header .header_tit {text-align: center; text-transform: uppercase; margin-top: 55px; font-family: 'Abel', sans-serif;}
.header .header_tit h1 {
	font-size: 30px; color: #fff;
	background: #51b0dc;
	display: inline-block;
	padding: 5px 30px;
	letter-spacing: 2px;
	font-weight: 900;
	transition: box-shadow .5s;
}
.header .header_tit h1:hover {
	box-shadow: inset 9em 0 0 0 #257fac,inset -9em 0 0 0 #257fac;
}
.header .header_tit a {
	font-size: 16px; color: #fff;
	background: #4a9abf;
	display: inline-block;
	padding: 10px 20px;
	margin-top: -7px;
	transition: box-shadow .25s;
}
.header .header_tit a:hover {
	box-shadow:
	0 0 0 5px rgba(75,154,191,0.9) inset,
	0 0 0 30px rgba(0,0,0,0.1) inset;
}
.header .header_icon {text-align: center; margin-top: 40px; padding-bottom: 45px;}
.header .header_icon li {display: inline; margin: 0 2px;}
.header .header_icon li a {
	position: relative;
	background-color: #3292bf;
	border-radius: 50%;
	width: 60px; height: 60px; color: #fff;
	display: inline-block;
	font-size: 35px; 
	line-height: 60px;
	transition: all 0.3s ease;
}
.header .header_icon li a span {
	position: absolute;
	left: 50%; top: -40px;
	transform: translateX(-50%);
	font-size: 12px;
	line-height: 1.6;
	background: #3192bf;
	padding: 3px 9px;
	border-radius: 6px 0; 
	opacity: 0;
	transition: all 0.3s ease;
}
.header .header_icon li a span::before {
	content: '';
	position: absolute;
	left: 50%; bottom: -5px;
	margin-left: -5px;
	border-top: 5px solid #3192bf; 
	border-left: 5px solid transparent; 
	border-right: 5px solid transparent; 
}
.header .header_icon li a:hover span {
	opacity: 1;
	top: -33px;
}
.header .header_icon li a:hover {
	box-shadow:
		0 0 0 3px rgba(75,154,191,0.9) inset,
		0 0 0 100px rgba(0,0,0,0.1) inset;
}

/* 전체 메뉴 */
.nav {overflow: hidden; padding: 0; height: 0;}

.nav > div {float: left; width: 40%;} /* html reference, css reference, Webstoryboy 부분 왼쪽 정렬 */
.nav > div:last-child {width: 20%;}
.nav > div ol {overflow: hidden;}
.nav > div li {width: 50%; float: left; position: relative; padding-left: 8px; box-sizing: border-box;}
.nav > div li::before {
	content: '';
	width: 3px; height: 3px;
	background-color: #25a2d0;
	border-radius: 50%;
	position: absolute; left: 0; top: 8px;
}
.nav > div:last-child li {width: 100%;}
.nav > div h3 {font-size: 18px; color: #25a2d0; font-weight: bold; margin-bottom: 4px;}
/* 라인 효과 */
.nav > div li a {position: relative;}
.nav > div li:hover a::after {/*opacity: 1;*/ width: 100%;}
.nav > div li a::after {
	content: '';
	width: 00%; height: 1px;
	background-color: #25a2d0;
	transition: all 0.1s ease-out;
	position: absolute; bottom: 0; left: 0;
	/*opacity: 0;*/
}

/* 타이틀 */
.title {position: relative; /*btn 클래스의 포지션 기준점으로 선정*/ text-align: center; /*웹 폰트 가운데 정렬*/}
.title h2 {font-family: 'Nanum Brush Script', cursive; font-size: 39px; color: #0093bd; /*웹 폰트 적용, 색상 지정, 폰트 크기 지정*/}
.title .btn {
	position: absolute; top: 0; right: 0; /*포지션 오른쪽 맨위(북동쪽) 설정*/
	width: 60px; height: 60px; /*배경색의 가로 폭 세로 높이 지정*/
	line-height: 60px; /*웹 폰트 i태그의 배경색 크기에 맞는 수직 정렬 용도로 사용*/
	background: #3192bf; color: #fff; /*배경색 설정, 폰트 색상 지정 */
	border-radius: 50%; /*배경 영역 모서리 부분 둥글게둥글게 효과 */
	font-size: 35px; /* 폰트 크기 지정 */
	transition: all 0.3s ease; /*트랜지션 효과 지정*/
}
.title .btn:hover { /* a 태그에 마우스 오버 했을 때 처리되는 부분 */
	box-shadow: 
		inset 0 0 0 3px rgba(71,154,191,1), /* 박스 쉐도우(그림자 효과) 안쪽(안쪽에서 바깥쪽)으로 그림자 효과 주기(색상 있음) */
		inset 0 0 0 100px rgba(0,0,0,0.1); /* 박스 쉐도우(그림자 효과) 안쪽(안쪽에서 안쪽)으로 그림자 효과 주기(색상 있음) */
}

/* 컨텐츠 영역 */
.column {padding: 15px;}
.column.col3 {border-bottom: 0;}
.column.col6 {border-bottom: 0;}
.column.col9 {border-bottom: 0;}
/* 컨텐츠 타이틀 */
.column .cont_tit {color: #2F7FA6; font-size: 20px; padding-bottom: 5px;}
.column .cont_desc {border-bottom: 1px dashed #dbdbdb; color: #878787; padding: 0 0 15px; margin: 0 0 15px; line-height: 18px;}

/* 메뉴 */
.menu li {position: relative;}
.menu li a {
    font-size: 16px; text-transform: uppercase;
    color: #878787;
    border-bottom: 1px solid #dbdbdb;
    padding: 10px; display: block;
    transition: box-shadow 0.34s ease, background 0.34s ease;
}
.menu li a i {
    position: absolute; right: 10px; top: 15px;
}
.menu li a:hover {
    box-shadow: inset 180px 0 0 0 rgba(36,130,174,0.7);
    color: #fff;
    background: rgba(36,130,174,0.9);
}

/* 게시판(한줄효과) */
.notice1 {overflow: hidden;}
.notice1 h5 {float: left; color: #2F7FA6; padding-bottom: 5px; font-size: 14px;}
.notice1 > a { display: block; text-align: right; font-size: 10px; color: #878787; text-transform: uppercase;}
.notice1 li {position: relative; clear: both; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-left: 8px;}
.notice1 li::before {
	content: '';
	width: 3px; height: 3px;
	border-radius: 50%;
	background: #0101DF;
	position: absolute; left: 0; top: 8px;
}
/* 게시판(두줄효과) 2 */
.notice2 {overflow: hidden; margin-top: 5px; }
.notice2 h5 {float: left; color: #2F7FA6; padding-bottom: 5px;}
.notice2 > a {display: block; text-align: right; font-size: 10px; color: #878787; text-transform: uppercase;}
.notice2 li { position: relative; overflow: hidden; clear: both; overflow: hidden; text-overflow: ellipsis; padding-left: 8px; margin-bottom: 5px;
	display: -webkit-box;
	-webkit-box-orient: vertical;
	-webkit-line-clamp: 2;
}
.notice2 li::before {
	content: '';
	width: 3px; height: 3px;
	border-radius: 50%;
	background: #0101DF;
	position: absolute; left: 0; top: 8px;
}

/* 블로그1 */
.blog1 img {width: 100%;}
.blog1 .img-retina {display: none;}

@media only screen and (-webkit-min-device-pixel-ratio: 1.5),
        only screen and (min-device-pixel-ratio: 1.5 /* 화면 비율이 1.5이상일 때 */),
        only screen and (min-resolution: 1.5dppx) {
        .blog1 .img-retina {display: initial;}
        .blog1 .img-normal {display: none;}
}

/* 블로그2 */
.blog2 h5 {color: #fff; text-align: center; padding: 30px 30px; text-transform: uppercase;}
.blog2 p {padding-top: 5px;}
.blog2 .img-retina {
	background-image: url(../img/blog4_@1.jpg);
	background-size: cover;
}
@media only screen and (-webkit-min-device-pixel-ratio: 2),
        only screen and (min-device-pixel-ratio: 2 /* 화면 비율이 2이상일 때 */),
        only screen and (min-resolution: 2dppx) {
        .blog2 .img-retina {background-image: url(../img/blog4_@2.jpg); background-size: cover;}
}
@media only screen and (-webkit-min-device-pixel-ratio: 2.6),
        only screen and (min-device-pixel-ratio: 2.6 /* 화면 비율이 2.6이상일 때 */),
        only screen and (min-resolution: 2.6dppx) {
        .blog2 .img-retina {background-image: url(../img/blog4_@3.jpg); background-size: cover;}
}

/* 반응형 이미지(이미지 슬라이드 설명부분("RESPONSIVE SITE" 부분)의 css 애니메이션 효과설정) */
.slider figure {position: relative;}
.slider figcaption {
	position: absolute; left: 0; bottom: 0; width: 100%;
	background: rgba(0,0,0,0.5); color: #fff;
	padding: 20px; box-sizing: border-box; 
	/* position: absolute; left: 0; bottom: 0; -> 텍스트를 이미지 속으로 배치위한 포지션 설정, 이미지 공간의 왼쪽아래로 배치.
	   width: 100%; -> 텍스트 가로폭 100%으로 처리.
	   background: rgba(0,0,0,0.5); color: #fff; -> 배경색: 검은색(투명도 0.5), 글자색상 흰색 설정;
	   box-sizing: border-box; -> 이걸 설정해주는 이유는 이미지를 포함하고 있는 공간인 figure태그에 포지션의 기준점을 잡아줬기 때문에
	   width:100%;를 했을 경우 figcaption태그의 부모인 figure태그 가로폭에 맞춰 100%로 유지하게된다. 이미지 속에 figcaption이 들어있으니
	   이미지에 맞춰서 가로폭이 결정되야하는거 아니냐 할 수 있지만 애초에 이미지 태그에는 position:relation;이 먹히지 않는다 그래서 figure태그에
	   기준점을 잡았고 그로인해 figcaption 태그의 가로폭이 유동적으로 바뀐다. 그런데 지금 padding:20px;을 주었다 이 패딩의 값은 figure태그의 가로폭과는
	   별개로 주어지는 값이다. 그래서 figcaption안에 있는 em태그, span태그의 영역들이 figure태그의 가로폭 영역을 벗어나게된다. 이걸 막는 방법은
	   figcaption태그에 따로 준 패딩값을 전체 가로폭에 포함시켜주면 figure태그의 가로폭 값과 같아지므로
	   패딩값을 전체 가로폭에 포함시켜주는 box-sizing: border-box; 구문을 실행시켜주면된다. */
}
.slider em {
	display: block; font-size: 28px; 
	text-transform: uppercase; 
	font-family: 'Abel', sans-serif; opacity: 0;
	transform: translateX(50px);
	/* display: block; -> 한줄을 꽉채우기위한 블럭 설정.
	font-size: 28px; text-transform: uppercase; font-family: 'Abel', sans-serif; -> 글자크기, 글자 대문자 변환, 글씨체 설정.
	opacity: 0; transform: translateX(50px); -> 텍스트에 css 애니메이션 효과를 주기위한 설정/
	opacity: 0; -> 불투명도 0, 즉 투명하게해서 안보이게 처리.
	transform: translateX(50px); -> em태그의 x축 위치를 오른쪽으로 50px 이동. */
}
.slider .slick-active em{
	opacity: 1;
	transition: all .84s ease;
	transform: translateX(0px);
	/* opacity: 1; -> 불투명도 100%, 즉 불투명하게해서 보이도록 처리.
	transition: all .84s ease; -> 트랜지션 효과 부여. 모든 속성에게 0.84초동안 ease 효과 생성
	transform: translateX(0px); -> em태그의 x축 위치를 0px 이동, 즉 아무이동 없음. */
}
.slider span {
	display: block; font-size: 18px;
 	white-space: nowrap; text-overflow: ellipsis; overflow: hidden;
 	opacity: 0;
	transform: translateX(100px);
	/* display: block; font-size: 18px; -> 블럭 요소로 변경, 글자 크기 지정.
 	white-space: nowrap; text-overflow: ellipsis; overflow: hidden; -> 한줄효과, 텍스트 넘칠 시 넘치는 부분...으로 보이게 처리, 넘치는 부분 숨기기 
 	opacity: 0; -> 불투명도 0, 즉 투명하게해서 안보이게 처리.
	transform: translateX(100px); -> span태그의 x축 위치를 오른쪽으로 100px 이동. */

}
.slider .slick-active span{
	opacity: 1;
	transition: all .84s .1s  ease;
	transform: translateX(0px);
	/* opacity: 1; -> 불투명도 100%, 즉 불투명하게해서 보이도록 처리.
	transition: all .84s .1s  ease ; -> 트랜지션 효과 부여. 모든 속성에게 0.84초동안 ease 효과 생성
	transform: translateX(0px); -> span태그의 x축 위치를 0px 이동, 즉 아무이동 없음. */
}
/* 반응형 이미지 슬라이드 해주는 버튼 부분 설정 */
.slider .slick-dots {display: block; text-align: center;} /* .slick-dots(ul태그) 블럭 요소로 변경, ul태그 전체 가운데 정렬. */
.slider .slick-dots li {
	display: inline-block; 
	width: 15px; height: 15px; margin: 5px;
} /* display: inline-block; -> ul 태그 인라인블럭 요소로 변경(ul태그안에 button요소 inline-block으로 변경),
	 width: 15px; height: 15px; margin:5px; -> li태그의 width, height 15px, margin:5px 설정. */
.slider .slick-dots li button {
	font-size: 0px; line-height: 0px; 
	display: block; cursor: pointer;
	width: 15px; height: 15px; background: #5dbfeb;
	border-radius: 50%;
	/* font-size: 0px; line-height: 0px; -> 기존 버튼모양 없애기위해 글자크기 0, 줄간격 0으로 처리
	display: block; cursor: pointer; -> 블럭 요소로 지정, 마우스 올릴 시 커서 모양 변경.
	width: 15px; height: 15px; background: #5dbfeb; -> 가로 폭, 세로 높이 15px 크기 지정, 배경색 지정.
	border-radius: 50%; -> 모서리부분 둥글게 지정. */
}
.slider .slick-dots li.slick-active button {background: #2b91c8;} /* 버튼 활성화 시 색깔 진하게 변경 */
/* 반응형 이미지 슬라이드 해주는 화살표 부분 설정 */
.slider .slick-prev {
	position: absolute; bottom: 0; left: 0;
	font-size: 0; line-height: 0;
	width: 30px; height: 30px; z-index: 1000;
	display: inline-block;
	text-indent: -9999px;
	/* position: absolute; bottom: 0; left: 0; 포지션 절대위치 선정, .slick-dots를 기준으로 맨왼쪽아래에 배치.
	   font-size: 0; line-height: 0; -> 글자크기, 줄간격 0으로 지정.
	   width: 30px; height: 30px; z-index: 1000; -> 가로 폭 세로 높이 지정, 스택 순서(z축)에 따른 화면 배치 선정.(자세한건 w3c 문서 참조)
	   display: inline-block; -> 인라인블럭 요소 설정
	   text-indent: -9999px; -> 원래 previous 라고 써있는 버튼이였으므로 "previous" 글자를 -9999px 위치로 설정. */
}
.slider .slick-prev::before {
	content: "\f053"; /* 웹 상에있는 폰트(폰트어썸) 위치 가져오기 */
	color: #5dbfed;
	text-indent: 0;
	position: absolute; left: 9px; top: 9px;
	font: normal normal normal 15px/1 FontAwesome; /* 웹 폰트 불러오는 작업 및 폰트의 여러 속성들을 한번에 설정. */
	/* ※부가 설명 : ; content: "\f053"는 폰트어썸이라는 플러그인에 있는 폰트중에 하나로 폰트어썸 홈페이지에서
	Directional Icons 코너의 "angle-left"라는 폰트로 이 페이지에서 "소스코드 검사"로 "<"모양의 버튼을 클릭하면
	가상요소인 ::before를 볼 수 있는데 거기에 content: "\f104"; 이런 식으로 써 있다. 이미지 태그를 직접 지정해서
	css 효과를 직접 줄 수 없기 때문에 이렇게 가상요소를 넣어서 처리한다. \f104는 웹 폰트상의 위치 번호이다
	지금 잘 모르겠는 건 왜 저 홈페이지에 나와있는 수치는 \f104인데 나는 \f053 이걸로 해야 되는지 잘 모르겠지만
	대략적으로는 이렇게 알아두자. */
}
.slider .slick-next {
	position: absolute; bottom: 0; right: 0;
	font-size: 0; line-height: 0;
	width: 30px; height: 30px; z-index: 1000;
	display: inline-block;
	text-indent: -9999px;
	/* position: absolute; bottom: 0; right: 0; 포지션 절대위치 선정, .slick-dots를 기준으로 맨오른쪽아래에 배치.
	   font-size: 0; line-height: 0; -> 글자크기, 줄간격 0으로 지정.
	   width: 30px; height: 30px; z-index: 1000; -> 가로 폭 세로 높이 지정, 스택 순서(z축)에 따른 화면 배치 선정.(자세한건 w3c 문서 참조)
	   display: inline-block; -> 인라인블럭 요소 설정 
	   text-indent: -9999px; -> 원래 previous 라고 써있는 버튼이였으므로 "previous" 글자를 -9999px 위치로 설정.*/
}
.slider .slick-next::before {
	content: "\f054"; /* 웹 상에있는 폰트(폰트어썸) 위치 가져오기 */
	color: #5dbfed;
	text-indent: 0;
	position: absolute; left: 11px; top: 9px;
	font: normal normal normal 15px/1 FontAwesome; /* 웹 폰트 불러오는 작업 및 폰트의 여러 속성들을 한번에 설정. */
	/* ※부가 설명 : ; content: "\f053"는 폰트어썸이라는 플러그인에 있는 폰트중에 하나로 폰트어썸 홈페이지에서
	Directional Icons 코너의 "angle-left"라는 폰트로 이 페이지에서 "소스코드 검사"로 "<"모양의 버튼을 클릭하면
	가상요소인 ::before를 볼 수 있는데 거기에 content: "\f104"; 이런 식으로 써 있다. 이미지 태그를 직접 지정해서
	css 효과를 직접 줄 수 없기 때문에 이렇게 가상요소를 넣어서 처리한다. \f104는 웹 폰트상의 위치 번호이다
	지금 잘 모르겠는 건 왜 저 홈페이지에 나와있는 수치는 \f104인데 나는 \f053 이걸로 해야 되는지 잘 모르겠지만
	대략적으로는 이렇게 알아두자. */
}
/* 라이트 박스(col5 부분) */
.square a {position: relative; overflow: hidden; float: left; width: 19%; margin: 0.5%;}
.square img {width: 100%; display: block;}
.square a em {background: rgba(0,0,0,0.77); color: #fff; width: 100%; text-align: center;
position: absolute; left: 0; bottom: -30px; opacity: 1; transition: all .3s ease;}
.square a:hover em {bottom: 0; background: rgba(0,0,0,0.57);}
.square a:nth-child(1):hover img {filter: blur(2px);}
.square a:nth-child(2):hover img {filter: brightness(50%);}
.square a:nth-child(3):hover img {filter: contrast(10%);}
.square a:nth-child(4):hover img {filter: grayscale(100%);}
.square a:nth-child(5):hover img {filter: hue-rotate(120deg);}
.square a:nth-child(6):hover img {filter: invert(100%);}
.square a:nth-child(7):hover img {filter: opacity(10%);}
.square a:nth-child(8):hover img {filter: saturate(10%);}
.square a:nth-child(9):hover img {filter: sepia(120%);}
.square a:nth-child(10):hover img {filter: sepia(120%) hue-rotate(120deg);}
button.lg-icon {
	background-color: rgba(0,0,0,0);
}

/* 비디오 나타내는 방법 2 */
.video {position: relative; width: 100%; padding-bottom: 60%;}
.video iframe {position: absolute; width: 100%; height: 100%;}

/* effect 효과 1 */
.side1 {position: relative; perspective: 600px;}
/* perspective -> 원근법 원리. 픽셀이 커질 수록 멀리서 보는 효과(반대로 작을 수록 가까이서 보는 효과.) */
.side1 .front {
	transform-style: preserve-3d; 
	transform: rotateY(0deg);
	transition: all 0.5s ease-in-out;
	backface-visibility: hidden;
}/* transform-style: preserve-3d; -> transform 스타일을 3d로 보여주겠다는 의미. 보통 2d로 보여짐. 
	transform: rotateY(0deg); -> 앞면에 배치된 이미지를 갖고있는 front 클래스이다 처음엔 0도 각도를 가지고 시작한다.
	backface-visibility: hidden; -> front 클래스의 뒷면을 보이지 않게 설정. 이 속성을 통해 이미지가 회전할 때
		back 클래스의 이미지가 보여질 수 있게된다. */
.side1:hover .front {
	transform: rotateY(180deg);
}/* transform: rotateY(180deg); -> y축을 기준으로 rotate(회전)을 180도 시계방향으로 돌리겠다는 의미.
	마우스 오버 했을 시에 앞에 배치된 front 클래스는 0도(마우스 오버 전)에서 180도(마우스 오버 후)로 돌 수 있게(시계방향) 설정. */
.side1 .front img {
	display: block;
}/* 부모 요소인 front 클래스랑 공간 크기를 맞춰주기위해서 display: block;로 설정. */
.side1 .back {
	transform-style: preserve-3d; transform: rotateY(-180deg); transition: all 0.5s ease-in-out;
	position: absolute; top: 0; left: 0; 
	width: 100%; height: 100%; z-index: -1;
	background: #4038dc;
}/* transition: all 0.5s ease-in-out; -> css의 속성값이 변하는 모든(all) 속성에 0.5초동안 
		ease-in-out(천천히 가다가 빨리갔다가 다시 천천히 도착하는 효과)를 지정.
	width: 100%; height: 100%; -> position: absolute; top: 0; left: 0;를 통해 부모 요소에 맨 왼쪽 위에 붙어있으므로
	 	크기를 맞추기위해 가로, 세로 100% 설정.
	z-index: -1; -> z축을 기준으로 -1로 설정. 화면에 여러개의 요소가 겹칠 때 보이는 순서를 정할 때 사용.
	transform: rotateY(-180deg); -> 뒷면에 배치된 back 클래스이다 처음엔 -180도 각도를 가지고 시작한다. */
.side1:hover .back {
	transform: rotateY(0deg);
}/* 마우스 오버 했을 시에 뒤에 배치된 back 클래스는 -180도(마우스 오버 전)에서 0도(마우스 오버 후)로 돌 수 있게(시계방향) 설정. */
.side1 .back i {
	position: absolute; top: 50%; left: 50%;
	transform: translate(-50%, -50%);
	font-size: 40px; color: #fff;
}/* position: absolute; top: 50%; left: 50%; -> i태그의 폰트어썸 이미지(글꼴 특성 지님)를 부모 요소인 back 클래스의 중앙에 배치하기 위한 설정. 
	transform: translate(-50%, -50%); -> x축, y축을 지정해 이동 시키는 속성.
		여기서는 i태그(폰트어썸 이미지)의 x축 -50%(자신의 width 값의 절반만큼 왼쪽으로 이동), y축 -50%(자신의 height 값의 절반만큼 위쪽으로 이동)로 이동하여 완전히 중앙에 정렬시키기 위함이다.
	font-size: 40px;, color: #fff; -> 폰트 어썸은 이미지처럼 생겼지만 글꼴의 특성을 지니고 있기 때문에 글자 색깔을 변경하면 이미지 색깔이 변함.(글자 크기도 마찬가지.) */

/* effect 효과 2 */
.side2 {position: relative; perspective: 600px;}
/* perspective -> 원근법 원리. 픽셀이 커질 수록 멀리서 보는 효과(반대로 작을 수록 가까이서 보는 효과.) */
.side2 .front {
	transform-style: preserve-3d;
	transform: rotateY(0deg);
	transition: all 0.5s ease-in-out;
	backface-visibility: hidden;
}/* transform-style: preserve-3d; -> transform 스타일을 3d로 보여주겠다는 의미. 보통 2d로 보여짐. 
	transform: rotateY(0deg); -> 앞면에 배치된 이미지를 갖고있는 front 클래스이다 처음엔 0도 각도를 가지고 시작한다.
	backface-visibility: hidden; -> front 클래스의 뒷면을 보이지 않게 설정. 이 속성을 통해 이미지가 회전할 때
		back 클래스의 공간이 보여질 수 있게된다. */
.side2 .front figcaption {
	position: absolute; top: 50%; left: 50%;
	transform: translate3d(-50%, -50%, 100px);
	background: rgba(0,0,0,0.4); color: #fff; padding: 3px 19px;
	white-space: nowrap; text-overflow: ellipsis; overflow: hidden;
	font-size: 20px; font-weight: bold; font-family: 'Abel', sans-serif;
	backface-visibility: hidden;
}/* position: absolute; top: 50%; left: 50%; -> side2 클래스를 기준으로 맨위에서 50%, 맨왼쪽에서 50% 이동한 위치에 배치함.
	transform: translate3d(-50%, -50%, 100px); -> 이번 이펙트 추가할 때 처음 사용했다.
		사용방법은 translate3d(x축 , y축, z축) 이런 식이며 좀더 자세히 말한다면
		x축(-50%) -> 요소의 width 값의 50%만큼 왼쪽으로(-, 마이너스) 이동(퍼센트 기준)
		y축(-50%) -> 요소의 height 값의 50%만큼 아래로(-, 마이너스) 이동(퍼센트 기준)
		z축(100px) -> z축은 3차원부터 존재하는 개념이며, 수치가 올라가면 갈수록 앞으로 튀어나와보이는 효과
	white-space: nowrap; text-overflow: ellipsis; overflow: hidden; -> 한줄 효과를 위한 설정.
	font-size: 20px; font-weight: bold; font-family: 'Abel', sans-serif; -> 글자 크기, 글자 진하게 표시, 글씨체 설정
	backface-visibility: hidden; -> 
	backface-visibility: hidden; -> front 클래스의 뒷면을 보이지 않게 설정. 이 속성을 통해 이미지가 회전할 때
		back 클래스의 이미지가 보여질 수 있게된다. */
.side2:hover .front {transform: rotateY(180deg);}
/* 마우스 안올렸을 때 0도 였다가 side2:hover 했을 때 front 클래스에 y축을 기준으로 180도 증가한(0도+180도=180도) 180도까지 시계방향으로 회전하라는 의미. */
.side2 .back {
	position: absolute; top: 0; left: 0;
	width: 100%; height: 100%; z-index: -1;
	transform-style: preserve-3d;
	transform: rotateY(-180deg);
	transition: all 0.5s ease-in-out;
	backface-visibility: hidden;
}/* position: absolute; top: 50%; left: 50%; -> side2 클래스를 기준으로 맨위에서 50%, 맨왼쪽에서 50% 이동한 위치에 배치함.
	width: 100%; height: 100%; z-index: -1; -> side2 클래스에 기준이 잡힌 back 클래스이므로 가로폭과 세로폭을 side2 클래스 공간에 맞춰 각각 100%으로 맞춘다.
	transform-style: preserve-3d; -> transform 스타일을 3d로 보여주겠다는 의미. 보통 2d로 보여짐. 
	transform: rotateY(-180deg); -> 뒷면에 배치된 이미지를 갖고있는 back 클래스이다 처음엔 =180도 각도를 가지고 시작한다.
	backface-visibility: hidden; -> back 클래스의 뒷면을 보이지 않게 설정. 이 속성을 통해 back 클래스의 뒷면의 공간이 
		mouse를 뗐을 때(hover 미적용시) 가려질 수 있게된다. */
.side2 .back figcaption {
	position: absolute; top: 50%; left: 50%;
	transform: translate3d(-50%, -50%, 100px);
	background: rgba(0,0,0,0.4); color: #fff; padding: 3px 19px;
	white-space: nowrap; text-overflow: ellipsis; overflow: hidden;
	font-size: 20px; font-weight: bold; font-family: 'Abel', sans-serif;
	backface-visibility: hidden;
}/* position: absolute; top: 50%; left: 50%; -> side2 클래스를 기준으로 맨위에서 50%, 맨왼쪽에서 50% 이동한 위치에 배치함.
	transform: translate3d(-50%, -50%, 100px); -> 이번 이펙트 추가할 때 처음 사용했다.
		사용방법은 translate3d(x축 , y축, z축) 이런 식이며 좀더 자세히 말한다면
		x축(-50%) -> 요소의 width 값의 50%만큼 왼쪽으로(-, 마이너스) 이동(퍼센트 기준)
		y축(-50%) -> 요소의 height 값의 50%만큼 아래로(-, 마이너스) 이동(퍼센트 기준)
		z축(100px) -> z축은 3차원부터 존재하는 개념이며, 수치가 올라가면 갈수록 앞으로 튀어나와보이는 효과
	white-space: nowrap; text-overflow: ellipsis; overflow: hidden; -> 한줄 효과를 위한 설정.
	font-size: 20px; font-weight: bold; font-family: 'Abel', sans-serif; -> 글자 크기, 글자 진하게 표시, 글씨체 설정
	backface-visibility: hidden; -> 
	backface-visibility: hidden; -> front 클래스의 뒷면을 보이지 않게 설정. 이 속성을 통해 이미지가 회전할 때
		back 클래스의 이미지가 보여질 수 있게된다. */
.side2:hover .back {transform: rotateY(0deg);}
/* 마우스 안올렸을 때 -180도 였다가 side2:hover 했을 때 back 클래스에 y축을 기준으로 180도 증가한(-180도+180도=0도) 0도까지 시계방향으로 회전하라는 의미. */

/* effect 효과 3 */
.side3 {position: relative; overflow: hidden; box-shadow: inset 0 0 0 150px black;}
/* position: relative; -> 하위 자식 요소들의 포지션(위치)의 기준이 되는 요소.
   overflow: hidden; -> 이 요소 밖으로는 보이징않게 설정. figcaption 요소를 위해 필요함.
   box-shadow: inset 0 0 0 150px black; -> img 요소에 opacity: 0.3;과 같이 사용했을 때 효과를 발휘. 
   		요소의 안쪽(inset)으로 그림자효과를 지정함. */
.side3 img {display: block;}
/* 부모 요소인 figure 공간 크기와 이미지 크기를 맞춰주기위해서 display: block;로 설정. */
.side3:hover img {opacity: 0.4;}
/* side3 클래스 공간에 마우스를 올렸을 때 이미지 어두워지는 효과.
		불투명도 0.4로 지정. box-shadow 속성이랑 같이 사용함. */
.side3 figure figcaption {
	position: absolute; top: 50%; left: 100%;
	transform: translateY(-50%) rotateZ(270deg);
	transition: all 0.3s ease-in-out; opacity: 0; padding: 20px 20px;
}/* position: absolute; top: 50%; left: 100%; -> side3 클래스의 기준으로 맨위에서 50% 아래에(Y축), 맨왼쪽에서 100% 위치(X축)에 배치.
	transform: translateY(-50%) rotateZ(270deg); -> translateY(-50%)로 Y축 재조정. rotateZ(270deg)로 마우스 오버시 회전하며 보이기위해 설정.
	transition: all 0.3s ease-in-out; opacity: 0; padding: 20px 20px; -> 회전하는 모습을 보여주기위해 트랜지션 효과 지정.
		패딩값 설정으로 글자 주위를 꾸며준다. */
.side3:hover figure figcaption {
	position: absolute; top: 50%; left: 50%;
	transform: translate(-50%, -50%) rotateZ(0deg);
	 opacity: 1; 
}/* position: absolute; top: 50%; left: 50%; -> 마우스 오버시에 대략적으로 글자가 위치될 곳 선정.
	transform: translate(-50%, -50%) rotateZ(0deg); -> position만으로는 예상하는 정확한 위치 선정이 힘들어 부가적으로 translate 설정.
		rotateZ(0deg)로 270도(마우스 오버 X)에서 0도(마우스 오버 O)로 반시계방향으로 돌아가도록 설정. */
.side3 h4{
	background: #000; color: #fff; border-radius: 50px; padding: 20px 20px;
	font-size: 20px; font-family: 'Abel', sans-serif;
	text-transform: uppercase; text-align: center;
}/* 배경색, 글자 색깔, 테두리 라운드효과 지정, 패딩 부여, 글자 크기, 글씨체, 대문자로 표시, 텍스트 가운데 정렬 등
	글자 부분에 대한 모든 것을 선언. */
.side3 em {font-weight: bold;} /* Effect 글씨 부분 진하게 표시 */



/* 푸터 */
.footer {text-align: center; padding: 30px 50px;}
.footer li {position: relative; display: inline; padding: 0 7px 0 11px; white-space: nowrap;}
.footer li:before {content: ''; width: 1px; height: 12px; background-color: #dbdbdb;
position: absolute; left: 0; top: 2px;}
.footer li:nth-child(1):before {display: none;}
/*.footer li:first-child:before {display: none;} -> 바로 위에 구문이랑 똑같이 작동하나 사용한 선택자가 다르다.(영상제작자 분의 방식) */
.footer address {padding-top: 15px;}
/* 구문 해석 : .footer {text-align: center; padding: 30px 50px;} -> 실질적인 푸터의 컨텐츠 영역. 전체 글씨 가운데 정렬과 패딩값 상하 30px, 좌우 50px 설정.
.footer li {position: relative; display: inline; padding: 0 7px 0 11px; white-space: nowrap;}
-> li태그안에 글씨들을 가운데 정렬하기위해 display: inline;을 해준다.(text-align 속성을 적용하기위해 - 블럭 요소안에 있는 인라인요소에 적용가능.)
white-space: nowrap; 을 통해 공간이 벗어나도 한줄의 전체 글자가 다 보이도록 설정하기 위함.
.footer li:before {content: ''; width: 1px; height: 12px; background-color: #dbdbdb;
position: absolute; left: 0; top: 2px;}
-> li태그의 가상요소를 넣어서 사이트 도움말, 사이트 이용약관 등 이러한 글씨 중간에 들어가는 막대기 모양을 만들기 위함.
position: absolute; left: 0; top: 2px; 을 통해 li태그 각각의 앞쪽에 li태그 기준으로 맨왼쪽, 위에서 2px 떨어진 곳에 가상요소를 배치하기위함.
position: relation; 을 통해 position: absolute;의 기준점을 생성.(여기선 li태그가 기준)
.footer li:nth-child(1):before {display: none;} -> 맨 처음에 들어가는 li태그의 막대기를 없애기 위함.
.footer address {padding-top: 15px;} -> 보기 좋게 여유 공간을 설정하기위한 패딩값.


/* mediaquery(화면 너비에 따른 화면 배치) */
/* 화면 너비 0 ~ 1220px */ 
@media (max-width: 1220px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}
	.title .btn {right: 15px;}
	
	#cont_entire .container {border: 0;} /* 가로 스크롤 바가 생기면 안되기 때문에 보더값 0으로 지정 */

	/* 이미지 라이트 박스 2단의 4개씩 총 8개 보이기 */
	.square a {width: 24%;}
	.square a:nth-child(5n) {display: none;}
}
/* 화면 너비 0 ~ 1024px */
@media (max-width: 1024px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}

	/* 이미지 라이트 박스 3단의 3개씩 총 9개 보이기 */
	.square a {width: 32.3333%;}
	.square a:nth-child(5) {display: block;}
}
/* 화면 너비 0 ~ 968px */
@media (max-width: 968px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}
	.nav > div {float: none; width: 100%;}
	.nav > div li {width: 33.3333%;}
	.nav > div:last-child {width: 100%;}
	.nav > div:last-child li {width: 33.3333%;}
	.nav > div ol {margin-bottom: 15px;}

	.content_center {border-right: 0; margin-right: 0;} /*오른쪽 컨텐츠가 내려가고나서 border값 바꾸기*/
	.content_right {position: static; width: 100%; border-top: 1px solid #dbdbdb;} /* position: static; -> 포지션을 기본값으로 만들어주는 거라고 함 좀더 공부할 것.*/

	/* col7,8,9 사이드 컨텐츠(이미지 3개 다 출력)*/
	.content_right {overflow: hidden;}
	.content_right .column {float: left; width: 33.3333%; box-sizing: border-box;}
	.content_right .col7 {border-right: 1px solid #ddd;}
	.content_right .col8 {border-right: 1px solid #ddd;}
}
/* 화면 너비 0 ~ 768px */
@media (max-width: 768px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}


	.content_left{width: 100%;} /* 화면 배치 변경에 따른 새로운 영역 설정을 위함.*/
	.content_center{clear: both; border-left: 0;} /*.content_left에 float:left;의 영향을 받고있기 때문에 float영향 해제를 위해 clear속성을 사용한다.*/
}
/* 화면 너비 0 ~ 600px */
@media (max-width: 600px) {
	/*.header {height: auto;} -> 이 방법을 쓸 것인가 아니면 11번째 라인 #header 자체에 height속성을 없앨 것인가 택1*/
	.header .header_tit {display: none;}
	.header .header_icon {display: none;}
	.title .btn {display: none;}
	.container {width: 100%;}
	.row {padding: 0 15px;}
	.nav > div li {width: 50%;}
	.nav > div:last-child li {width: 50%;}
	/*왼쪽 컨텐츠의 col1 부분 */
	.column.col1 {padding: 0; border-bottom: 0;}
	.col1 .cont_tit {display: none;}
	.col1 .cont_desc1 {display: none;}
	.col1 .menu i {display: none;}
	.col1 .menu li {border-right: 1px solid #fff; box-sizing: border-box;}
	.col1 .menu li a {border-color: #fff; text-align: center; color: #fff; text-shadow: 0 0 5px rgba(0,0,0,0.7);}
	.col1 .menu li a:hover { box-shadow: none; background-color: rgba(36,130,174,0.3);}
	.col1 .menu_first {overflow: hidden;}
	.col1 .menu_first li {float: left; width: 33.3333%;}
	.col1 .menu_first li:last-child {border-right: 0;}
	.col1 .menu_second {clear: both; overflow: hidden;}
	.col1 .menu_second li {float: left; width: 33.3333%;}
	.col1 .menu_second li a {border-bottom: 0;}
	.col1 .menu_second li:last-child {border-right: 0;}
	.col2 {clear: both; background-color: #fff;}

	/* 이미지 설명부분(figcaption) 화면크기 600px이하일 때 */
	.slider .slick-active em {font-size: 20px;}
	.slider .slick-active span {font-size: 13px;}

	/* 이미지 라이트 박스 2단의 4개씩 총 8개 보이기 */
	.square a {width: 49%;}
	.square a:nth-child(5) {display: none;}

	/* col7,8,9 사이드 컨텐츠(이미지 2개만 출력) */
	.content_right .column {width: 50%;}
	.content_right .column.col8 {border-right: 0;}
	.content_right .column.col9 {display: none;}
}
/* 화면 너비 0 ~ 480px */
@media (max-width: 480px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}
	.nav > div {width: 100%;}
	.nav > div:last-child {width: 100%;}
}
/* 화면 너비 0 ~ 320px */
@media (max-width: 320px) {
	.container {width: 100%;}
	.row {padding: 0 15px;}
	.nav > div li {width: 100%;}
	.nav > div:last-child li {width: 100%;}

	/* 이미지 라이트 박스 1단의 8개씩 총 8개 보이기 */
	.square a {width: 100%;}

	/* col7,8,9 사이드 컨텐츠(이미지 1개씩 2단 출력) */
	.content_right .column {width: 100%;}
	.content_right .column.col7 {border-right: 0; border-bottom: 1px solid #dbdbdb;}
}